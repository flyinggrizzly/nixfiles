wiggum() {
    local prompt_file max_iterations iteration current_branch custom_prompt no_git model

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--prompt)
                custom_prompt="$2"
                shift 2
                ;;
            --no-commit|--no-git)
                no_git=1
                shift
                ;;
            -i|--iterations)
                max_iterations="$2"
                shift 2
                ;;
            -m|--model)
                model="$2"
                shift 2
                ;;
            -*)
                echo "Error: Unknown option '$1'"
                echo "Usage: wiggum [-p|--prompt <file>] [-i|--iterations <n>] [-m|--model <model>] [--no-commit]"
                return 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'"
                echo "Usage: wiggum [-p|--prompt <file>] [-i|--iterations <n>] [-m|--model <model>] [--no-commit]"
                return 1
                ;;
        esac
    done

    max_iterations="${max_iterations:-0}"
    prompt_file="${custom_prompt:-PROMPT.md}"

    iteration=0
    current_branch=$(git branch --show-current)

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Prompt: $prompt_file"
    echo "Model:  ${model:-opus}"
    echo "Branch: $current_branch"
    [[ $max_iterations -gt 0 ]] && echo "Max:    $max_iterations iterations" || echo "Max:    unlimited"
    [[ -z "$no_git" ]] && echo "Commit: true" || echo "Commit: false"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [[ ! -f "$prompt_file" ]]; then
        echo "Error: $prompt_file not found"
        return 1
    fi

    local total_duration=0
    local total_input_tokens=0
    local total_output_tokens=0

    while true; do
        iteration=$((iteration + 1))
        echo -e "\n======================== LOOP $iteration ========================\n"

        if [[ $max_iterations -gt 0 ]] && [[ $iteration -gt $max_iterations ]]; then
            echo "Reached max iterations: $max_iterations"
            break
        fi

        local start_time=$(date -Iseconds)
        local output=$({
            cat "$prompt_file"
            cat <<EOF

ONLY WORK ON A SINGLE TASK.

## Git rules

DO NOT RUN ANY GIT COMMANDS. Wiggum handles commits automatically after each iteration.

If your instructions mention git operations, IGNORE THEM - wiggum manages version control.

## Files rules

UNDER NO CIRCUMESTANCES SHOULD YOU MODIFY, DELETE, etc FILES LIKE:

- untracked markdown files, especially not ones named PROMPT.md
- wiggum_log.json

## Iteration context

This prompt is iteration number $iteration.

ONLY WORK ON A SINGLE TASK.

## Response format

Your final line of output MUST be raw JSON (not wrapped in markdown) in this exact format:

{"done":false,"success":true,"summary":"CSS added to style header","steps_taken":["decided to name CSS file foo.css","created CSS file"],"commands_run":["touch ./foo.css"],"issues_encountered":[]}

Set "done":true when there is no further work to do. Set "done":false if more iterations are needed.
EOF
        } | claude -p \
            --dangerously-skip-permissions \
            --output-format=json \
            --model "${model:-opus}")
        local end_time=$(date -Iseconds)

        local result_text=$(echo "$output" | jq -r '.result // empty')
        local json_line=$(echo "$result_text" | grep '^{' | tail -1)
        local log_json=$(echo "$json_line" | jq -c '.' 2>/dev/null)

        if [[ -z "$log_json" ]]; then
            echo "Warning: Failed to parse log JSON"
            echo "Last JSON-like line: $json_line"
            continue
        fi

        if [[ $(echo "$log_json" | jq -r '.done') == "true" ]]; then
            echo "Work complete (done:true)"
            break
        fi
        local input_tokens=$(echo "$output" | jq -r '.usage.input_tokens // 0')
        local output_tokens=$(echo "$output" | jq -r '.usage.output_tokens // 0')
        local start_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${start_time%[-+]*}" "+%s" 2>/dev/null)
        local end_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${end_time%[-+]*}" "+%s" 2>/dev/null)
        local duration_secs=$((end_epoch - start_epoch))

        local entry=$(echo "$log_json" | jq \
            --arg start "$start_time" \
            --arg end "$end_time" \
            --argjson iter "$iteration" \
            --argjson input "${input_tokens:-0}" \
            --argjson output "${output_tokens:-0}" \
            --argjson duration "$duration_secs" \
            '. + {iteration: $iter, start_time: $start, end_time: $end, duration_secs: $duration, input_tokens: $input, output_tokens: $output}')

        if [[ -f "wiggum_log.json" ]]; then
            jq --argjson entry "$entry" '. += [$entry]' wiggum_log.json > wiggum_log.json.tmp && mv wiggum_log.json.tmp wiggum_log.json
        else
            echo "[$entry]" | jq '.' > wiggum_log.json
        fi

        echo -e "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "$entry" | jq -r '"Success:  \(.success)\nSummary:  \(.summary)\nSteps:    \(.steps_taken | join(", "))\nCommands: \(.commands_run | join(", "))\nIssues:   \(.issues_encountered | if length == 0 then "none" else join(", ") end)\nDuration: \(.duration_secs)s\nTokens:   \(.input_tokens) in / \(.output_tokens) out"'
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

        total_duration=$((total_duration + duration_secs))
        total_input_tokens=$((total_input_tokens + input_tokens))
        total_output_tokens=$((total_output_tokens + output_tokens))

        [[ -z "$no_git" ]] && git commit -am "Wiggum iteration $iteration"
    done

    echo -e "\n════════════════════════════════════════"
    echo "TOTALS"
    echo "════════════════════════════════════════"
    echo "Iterations: $((iteration - 1))"
    echo "Duration:   ${total_duration}s"
    echo "Tokens:     ${total_input_tokens} in / ${total_output_tokens} out"
    echo "════════════════════════════════════════"
}
