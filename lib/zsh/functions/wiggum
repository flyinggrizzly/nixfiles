wiggum() {
    local prompt_file max_iterations iteration current_branch custom_prompt no_git model

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--prompt)
                custom_prompt="$2"
                shift 2
                ;;
            --no-commit|--no-git)
                no_git=1
                shift
                ;;
            -i|--iterations)
                max_iterations="$2"
                shift 2
                ;;
            -m|--model)
                model="$2"
                shift 2
                ;;
            -*)
                echo "Error: Unknown option '$1'"
                echo "Usage: wiggum [-p|--prompt <file>] [-i|--iterations <n>] [-m|--model <model>] [--no-commit]"
                return 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'"
                echo "Usage: wiggum [-p|--prompt <file>] [-i|--iterations <n>] [-m|--model <model>] [--no-commit]"
                return 1
                ;;
        esac
    done

    max_iterations="${max_iterations:-0}"
    prompt_file="${custom_prompt:-PROMPT.md}"

    iteration=0
    current_branch=$(git branch --show-current)

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Prompt: $prompt_file"
    echo "Model:  ${model:-opus}"
    echo "Branch: $current_branch"
    [[ $max_iterations -gt 0 ]] && echo "Max:    $max_iterations iterations" || echo "Max:    unlimited"
    [[ -z "$no_git" ]] && echo "Commit: true" || echo "Commit: false"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [[ ! -f "$prompt_file" ]]; then
        echo "Error: $prompt_file not found"
        return 1
    fi

    local total_duration=0
    local total_input_tokens=0
    local total_output_tokens=0

    while true; do
        iteration=$((iteration + 1))
        echo -e "\n======================== LOOP $iteration ========================\n"

        if [[ $max_iterations -gt 0 ]] && [[ $iteration -gt $max_iterations ]]; then
            echo "Reached max iterations: $max_iterations"
            break
        fi

        local start_time=$(date -Iseconds)
        local output=$({
            cat "$prompt_file"
            cat <<EOF

ONLY WORK ON A SINGLE TASK.

## Iteration context

This prompt is iteration number $iteration.

After you have completed the task, output a log entry as JSON on a single line prefixed with WIGGUM_LOG:

\`\`\`
WIGGUM_LOG:{"success":true,"summary":"CSS added to style header","steps_taken":["decided to name CSS file foo.css","created CSS file"],"commands_run":["touch ./foo.css"],"issues_encountered":[]}
\`\`\`

ONLY WORK ON A SINGLE TASK.

If there is no further work to do, output exactly WIGGUM:OVER instead of a log entry.

ONLY WORK ON A SINGLE TASK.
EOF
        } | claude -p \
            --dangerously-skip-permissions \
            --output-format=json \
            --model "${model:-opus}")
        local end_time=$(date -Iseconds)

        local result_text=$(echo "$output" | jq -r '.result // empty')

        if [[ "$result_text" == *"WIGGUM:OVER"* ]]; then
            echo "Work complete (WIGGUM:OVER)"
            break
        fi
        local log_json=$(echo "$result_text" | grep -oE 'WIGGUM_LOG:\{[^}]+\}' | head -1 | sed 's/WIGGUM_LOG://')
        local input_tokens=$(echo "$output" | jq -r '.usage.input_tokens // 0')
        local output_tokens=$(echo "$output" | jq -r '.usage.output_tokens // 0')
        local start_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${start_time%[-+]*}" "+%s" 2>/dev/null)
        local end_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${end_time%[-+]*}" "+%s" 2>/dev/null)
        local duration_secs=$((end_epoch - start_epoch))

        if [[ -n "$log_json" ]]; then
            local entry=$(echo "$log_json" | jq \
                --arg start "$start_time" \
                --arg end "$end_time" \
                --argjson iter "$iteration" \
                --argjson input "${input_tokens:-0}" \
                --argjson output "${output_tokens:-0}" \
                --argjson duration "$duration_secs" \
                '. + {iteration: $iter, start_time: $start, end_time: $end, duration_secs: $duration, input_tokens: $input, output_tokens: $output}')

            if [[ -f "wiggum_log.json" ]]; then
                jq --argjson entry "$entry" '. += [$entry]' wiggum_log.json > wiggum_log.json.tmp && mv wiggum_log.json.tmp wiggum_log.json
            else
                echo "[$entry]" | jq '.' > wiggum_log.json
            fi

            echo -e "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "$entry" | jq -r '"Success:  \(.success)\nSummary:  \(.summary)\nSteps:    \(.steps_taken | join(", "))\nCommands: \(.commands_run | join(", "))\nIssues:   \(.issues_encountered | if length == 0 then "none" else join(", ") end)\nDuration: \(.duration_secs)s\nTokens:   \(.input_tokens) in / \(.output_tokens) out"'
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

            total_duration=$((total_duration + duration_secs))
            total_input_tokens=$((total_input_tokens + input_tokens))
            total_output_tokens=$((total_output_tokens + output_tokens))
        fi

        [[ -z "$no_git" ]] && git commit -am "Wiggum iteration $iteration"
    done

    echo -e "\n════════════════════════════════════════"
    echo "TOTALS"
    echo "════════════════════════════════════════"
    echo "Iterations: $((iteration - 1))"
    echo "Duration:   ${total_duration}s"
    echo "Tokens:     ${total_input_tokens} in / ${total_output_tokens} out"
    echo "════════════════════════════════════════"
}
