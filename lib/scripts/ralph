#!/usr/bin/env ruby

require 'date'
require 'json'
require 'optparse'
require 'open3'

def parsed_loop_options
  options = {
    "model" => "opus",
    "completion_promise" => "ALLDONE",
    "max_iterations" => 100,
  }

  OptionParser.new do |opts|
    opts.on('--prompt PROMPT', 'prompt') { |it| options["prompt"] = it }
    opts.on('--completion-promise COMPLETION_PROMISE', 'completion promise') { |it| options["completion_promise"] = it }
    opts.on('--max-iterations MAX_ITERATIONS', 'maximum iterations') { |it| options["max_iterations"] = it.to_i }
    opts.on('--model MODEL', 'model to use') { |it| options["model"] = it }
  end.parse!

  options
end

def parsed_next_options
  options = {
    "file" => 'ralph-tasks.json',
    "open_status" => 'open',
  }

  OptionParser.new do |opts|
    opts.on('--file FILE', 'task file') { options["file"] = it }
    opts.on('--open-status STATUS', 'status indicating open task') { options["open_status"] = it }
  end.parse!

  options
end

def parsed_update_options
  options = {
    "file" => 'ralph-tasks.json',
  }

  OptionParser.new do |opts|
    opts.on('--file FILE', 'task file') { options["file"] = it }
    opts.on('--id ID', 'task identifier') { options["id"] = it }
    opts.on('--status STATUS', 'updated status') { options["status"] = it }
    opts.on('--comment "COMMENTS IN QUOTES"', 'comment on result') { options["comments"] = it }
    opts.on('--pull-request PULL_REQUEST', 'optional PR URL') { options["pull_request"] = it }
  end.parse!

  options
end

class Loop
  def initialize(prompt:, completion_promise:, max_iterations:, model:)
    @prompt_file = prompt
    @completion_promise = completion_promise
    @max_iterations = max_iterations
    @model = model
    @iteration = 0
  end

  attr_reader :completion_promise, :max_iterations, :iteration, :model, :prompt_file

  def run!
    puts <<~START

      === Ralph: starting run ===
          prompt:             #{prompt_file}
          model:              #{model}
          max_iterations:     #{max_iterations}
          completion_promise: #{completion_promise}
      ===========================

    START

    while iteration < max_iterations
      puts "=== Ralph: iteration #{iteration + 1} ==="

      stdout, stderr, status = Open3.capture3(
        "claude -p --dangerously-skip-permissions --model #{model}",
        stdin_data: prompt
      )

      if status.success?
        puts stdout

        if stdout.include?(completion_promise)
          puts "=== Ralph: received completion promise '#{completion_promise}'. Exiting. ==="
          exit 0
        end

        @iteration += 1
      else
        puts stderr
        exit 1
      end
    end

    puts "=== Ralph: performed #{iteration} iterations. Exiting. ==="
  end

  def prompt
    <<~PROMPT
      #{prompt_file}

     ## Tool reference

     - `./ralph help` prints usage
     - `./ralph next-task` - returns JSON of the task to work on.
       - If it returns `'{ "_no_remaining_tasks": true }'`, that means no tasks remain to work on. Immediately exit
     - `./ralph update-task` - updates the status and data on a task. Use it to update tasks after you have attempted them.
    PROMPT
  end
end

class NextTask
  def initialize(file:, open_status:)
    @file = file
    @open_status = open_status
  end

  attr_reader :file, :open_status

  def get!
    data = JSON.parse(File.read(file))
    next_task = data.find { |d| d["status"] == open_status }

    if next_task.nil?
      return { "_no_remaining_tasks" => true }
    end

    next_task
  end
end

class UpdateTask
  def initialize(file:, task_id:, status:, comment:, pull_request: nil)
    @file = file
    @task_id = task_id
    @status = status
    @comment = comment
    @pull_request = pull_request
  end

  attr_reader :file, :task_id, :status, :comment, :pull_request

  def update!
    data = JSON.parse(File.read(file))
    task_index = data.index { |d| d["id"] == task_id }

    comments = task["comments"] || []
    comments << {
      "time": DateTime.now.iso8601,
      "comment" => comment
    }

    data[task_index] = datum.merge({
      "status" => status,
      "comments" => comments,
      "pull_request" => options.fetch("pull_request", nil)
    })

    File.write(file, JSON.pretty_generate(data))
  end
end

LOOP_COMMAND = "loop"
NEXT_COMMAND = "next-task"
UPDATE_COMMAND = "update-task"
HELP_COMMAND = "help"

command = ARGV.shift

case command
when LOOP_COMMAND
  loop_options = parsed_loop_options

  Loop.new(
    prompt: loop_options.fetch("prompt"),
    completion_promise: loop_options.fetch("completion_promise"),
    max_iterations: loop_options.fetch("max_iterations"),
    model: loop_options.fetch("model"),
  ).run!
when NEXT_COMMAND
  next_options = parsed_next_options

  puts JSON.pretty_generate(
    NextTask.new(
      file: next_options.fetch("file"),
      open_status: next_options.fetch("open_status"),
    ).get!
  )
when UPDATE_COMMAND
  update_options = parsed_update_options

  UpdateTask.new(
    file: update_options.fetch("file"),
    task_id: update_options.fetch("id"),
    status: update_options.fetch("status"),
    comment: update_options.fetch("comments", nil),
    pull_request: update_options.fetch("pull_request", nil),
  ).update!
when HELP_COMMAND
  puts <<~HELP
    Usage: ralph loop --prompt <prompt> --completion-promise <completion_promise> --max-iterations <max_iterations> [--model <model=opus>]
    Usage: ralph next-task [--file <task_file=ralph-tasks.json>] [--open-status <open_status=open>]
    Usage: ralph update-task --id <task_id> --status <status> [--comment "comments in quotes"] [--pull-request <pull_request>] [--file <task_file=ralph-tasks.json>]
  HELP
else
  raise "Unknown command: #{command}"
end


